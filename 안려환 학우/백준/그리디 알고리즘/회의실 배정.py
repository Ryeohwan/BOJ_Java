import sys

# 문제 풀이를 위한 이해 
# 회의를 가장 많이 집어넣으려면 끝나는 시간이 빠른 회의들을
# 먼저 정렬해서 찾아줘야하는 것이고 이 후에 시작시간인데
# 이도 사실 끝과 시작이 같은 회의를 찾아서 먼저 넣어주어야 한다.
# 예를 들어서 
# 0 10 인 회의는 시작시간으로 정렬을 하게 되면 
# 10에 끝나서 많은 회의를 집어넣지 못하게 된다.
# 걍 끝나는게 빠른 것으로 정렬해서 풀어버리면 된다.

n = int(sys.stdin.readline())
mtng_list = [0 for _ in range(n)]
end_list = [0 for _ in range(n)]

for i in range(n):
    mtng_list[i] = list(map(int,sys.stdin.readline().split()))

# 정리한 것 처럼 끝나는 시간이 빠른 것들로 먼저 계산
# 이거 정렬을 해주고 싶은데 정렬을 해주려면 
# 먼저 끝나는 시간을 전부 받아오고 그에 대한 인덱스도 다 가져온다
# 그래서 그 인덱스를 가지고 정렬된 만큼 앞 시작 시간에 대한 값들도
# 전부 가져와서 리스트를 가지고 있는 리스트에 합쳐준다.
# 그래서 검색을 해봤는데 이런 복잡한 과정을 피할 수 있는 것이
# 람다식을 이용하는 것에 있었다.
# 방법은 mtng_list.sort(key = lamda x: (x[1],x[0]))
# 이렇게 하는 것이라고 한다.

mtng_list.sort(key= lambda x: (x[1],x[0]))
# 이렇게 하니 일단 1번 인덱스 값을 기준으로 정렬을 해주었다. 

count = 1 # 인덱스 0에 있는 것이 이미 쓰여서 1부터 카운트
end_time = mtng_list[0][1] # 정렬된 것이기 때문에 이거 먼저 일단 끝나는 시간으로 설정

for i in range(1,n): # 0은 이미 엔드타임으로 쓰였기에 
    if mtng_list[i][0] >= end_time: # 시간이 같거나 크면으로만 따져도 이미 정렬된 것
        count += 1
        end_time = mtng_list[i][1] # 그리고 끝나는 시간 다시 설정

print(count)

# 저 람다식을 몰라서 이렇게 되었읍니다...